# Описание плана работы

## Что реализовано
* Написан сервер, который может выдавать статические страницы и выводить список файлов в каталоге (несколько подключений обслуживаются одновременно)
* Сервер корректно обрабатывает ошибочные запросы
* Поддерживается возможность исполнения CGI скриптов (несколько примеров в test/: send, variables, counter)

## Что предполагается реализовать
* Добавить функциональность изоляции опасных скриптов при помощи chroot
* Оформить сервер в виде службы systemd
* Произвести более качественное тестирование производительности и сравнить с конкурентами в равных условиях (открытие одной и той же страницы, подсчёт реального времени исполнения)
* Добавить поддержку дополнительных опций командной строки и/или конфигурационных файлов

## Что не будет реализовано
* Поддержка POST-запросов

# Отчёт
## Введение в предметную область, актуальность работы, обзор существующих решений.
Веб-сервер - это программа, принимающая HTTP-запросы от клиентов (обычно веб-браузеров) и выдающая им HTTP-ответы (обычно вместе с HTML-страницей, изображением, файлом, медиа-потоком или другими данными). В настоящее время существует достаточно серверов, наиболее функциональные, известные и часто используемые из них - Apache, nginx и библиотеки для языков высокого уровня, реализующие почти всю необходимую функциональность (например, http.server для Python 3). Apache и является основным конкурентом (nginx не предназначен для запуска cgi-скриптов, его применение целесообразно прежде всего для статических веб-сайтов и как прокси-сервера перед динамическими сайтами). Их код сложен для понимания, и может содержать ошибки, в том числе опасные уязвимости. Актуальность данной работы состоит в написании простого сервера, не использующего сторонних библиотек (только libstdc++ и POSIX API), код которого можно быстро изучить и верифицировать. Современные веб-сервера поддерживают дополнительные возможности, такие как https, FastCGI (и другие протоколы взаимодействия с приложениями), POST (и другие виды запросов), авторизацию пользователей. При необходимости можно их добавить и к navajo. В целом, принцип работы всех серверов одинаков, но некоторые из них используют различные приёмы ускорения работы (например, очередь событий ядра epoll вместо создания отдельных процессов на каждое подключение при раздаче статических страниц, а также создания процессов заранее, во время простоя).

## Описание проделанной работы
Написан сервер, отчёт, проведено черновое сравнение производительности с Apache.

### Описание архитектуры программного продукта
Сервер написан на C++ с использованием POSIX API для вызова функций, предоставляемых ОС. Использование RAII и стандартных контейнеров C++ позволяет переложить рутинную работу с выделением и освобождением памяти на компилятор, и, таким образом, избавиться от риска ошибок при работе с ней. Для сборки используется CMake. Исходный код состоит из 4 файлов с исходным кодом и заголовков для них. В common.cpp содержатся общезначимые константы и функции, в query_parser.cpp - функции для обработки запросов клиента, в answer_generator.cpp - функции ответа сервера на запросы, в main.cpp - код основной программы.

### Инструкция по компиляции, установке, настройке и запуску
* Установите компилятор языка C++

```
sudo apt install g++
```

* Перейдите в каталог, содержащий данный файл

* Компиляция

```
mkdir build
cd build
cmake ..
make
```

* Установка

```make install```

* Запуск

```navajo [PORT]```

* Если требуется другой рабочий каталог, нужно сначала перейти в него

### Руководство пользователя
Запустите сервер (в первом аргументе командной строки можно указать нужный порт, по умолчанию 1200). Откройте в браузере страницу localhost:1200 и попробуйте открыть разные файлы и каталоги. Проверьте, что сервер обрабатывает ошибочные запросы (запрос несуществующего файла, попытка доступа к файлу без соответствующих прав доступа). Убедитесь, что стандартные типы файлов (pdf, png, mp3) не скачиваются, а открываются в браузере, как и должны.

## Результат - что сделано, сравнение с конкурентами
Как и планировалось, получился простой и быстрый сервер. По результатам тестирования производительности на рабочей машине автора navajo оказался на 18% быстрее Apache (28 секунд на обработку 2500 последовательных запросов против 34 секунд). Тестирование производилось на настройках Apache по умолчанию с применением простой команды date и подсчётом разности времени до и после запуска (исходный код в test/performance, необходимо иметь запущенный на порту 80 сервер перед запуском). Позднее будет проведено более качественное сравнение.
